<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Knockout : Computed Observables</title>
        <link href="../css/tripoli.simple.css" type="text/css" rel="stylesheet" /> 
        <link rel="stylesheet" type="text/css" href="../css/styles.css" />
        <link rel="stylesheet" type="text/css" href="../css/smallScreen.css" media="only screen and (max-device-width: 800px)" />
        <!--[if IE]><link rel="stylesheet" type="text/css" href="../css/tripoli.simple.ie.css" /><![endif]-->
        <!--[if lte IE 7]><link rel="stylesheet" type="text/css" href="../css/ie6ie7.css" /><![endif]-->
        <!--[if lte IE 6]><link rel="stylesheet" type="text/css" href="../css/ie6.css" /><![endif]-->
        <script type="text/javascript" src="../js/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="../js/knockout-2.1.0.js"></script>
<script type="text/javascript" src="../js/cufon-yui.js"></script>
<script type="text/javascript" src="../js/titilliummaps.font.js"></script>
<script type="text/javascript" src="../js/json2.js"></script>

<!--[if lt IE 7]>
<script defer type="text/javascript" src="../js/ie6pngfix.js"></script>
<![endif]-->

<script type="text/javascript" src="../js/syntaxhighlighter_3.0.83/scripts/shCore.js"></script> 
<script type="text/javascript" src="../js/syntaxhighlighter_3.0.83/scripts/shBrushJava.js"></script> 
<script type="text/javascript" src="../js/syntaxhighlighter_3.0.83/scripts/shBrushXml.js"></script> 
<link type="text/css" rel="stylesheet" href="../js/syntaxhighlighter_3.0.83/styles/shThemeFadeToGrey.css"/>  

<script type="text/javascript">
    $(function() {
        // Fancy fonts
        Cufon.replace('.titillium');
        Cufon.replace('.engraved', {
            textShadow: 'rgba(253, 224, 217, 0.45) 1.2px 1px'	
        });
        
        // Syntax highlighting
        $("pre > code").each(function() {
            var codeText = $(this).text();
            $(this).parent().text(codeText).addClass("brush:js");
        });
        SyntaxHighlighter.defaults['toolbar'] = false;
        SyntaxHighlighter.defaults['gutter'] = false;
        SyntaxHighlighter.all();
        
        // Highlight current top menu item
        var desiredMenuItem = '' || 'documentation';
        $(".main-menu a[rel=" + desiredMenuItem + "]").addClass("active");
        
        // Highlight current left-hand-nav menu item
        var urlFilename = location.href.match(/\/([^\/]+)$/);
        if (urlFilename) {
            $(".leftColContents li:has(a[href$=" + urlFilename[1] + "])").addClass("active");
        }
    });
</script> 
    </head>
    <body>
        <div id="wrapper">
            <div class="vspace"></div>
            <div class="main-menu">
    <ul>
        <li><a rel="home" href="../index.html">Home</a></li>
        <li><a rel="installation" href="../documentation/installation.html">Download / Install</a></li>
        <li><a rel="tutorials" href="http://learn.knockoutjs.com/">Tutorials</a></li>
        <li><a rel="examples" href="../examples/">Live examples</a></li>
        <li><a rel="documentation" href="../documentation/introduction.html">Documentation</a></li>
        <li><a href="http://groups.google.com/group/knockoutjs">Forum</a></li>
        <li><a href="http://github.com/SteveSanderson/knockout">Source</a></li>
    </ul>
</div>        	
<div class="clear"></div>
            <div class="vspace"></div>
            <div>	
	<div class="leftCol">		
		<div class="leftColBackground">&nbsp;</div>
		<div class="leftColContents">
			<h1>Getting started</h1>

<ol>
    <li><a href="introduction.html">How KO works and what benefits it brings</a></li>
    <li><a href="installation.html">Downloading and installing</a></li>
</ol>

<h1>Observables</h1>

<ol>
    <li><a href="observables.html">Creating <em>view models</em> with <em>observables</em></a></li>
    <li><a href="computedObservables.html">Using <em>computed observables</em></a></li>
    <li><a href="observableArrays.html">Working with <em>observable arrays</em></a></li>	
</ol>

<h1>Using built-in bindings</h1>

<h2>Controlling text and appearance</h2>
<ol>
    <li><a href="visible-binding.html">The <code>visible</code> binding</a></li>
    <li><a href="text-binding.html">The <code>text</code> binding</a></li>
    <li><a href="html-binding.html">The <code>html</code> binding</a></li>
    <li><a href="css-binding.html">The <code>css</code> binding</a></li>
    <li><a href="style-binding.html">The <code>style</code> binding</a></li>
    <li><a href="attr-binding.html">The <code>attr</code> binding</a></li>
</ol>

<h2>Control flow</h2>
<ol>
    <li><a href="foreach-binding.html">The <code>foreach</code> binding</a></li>
    <li><a href="if-binding.html">The <code>if</code> binding</a></li>
    <li><a href="ifnot-binding.html">The <code>ifnot</code> binding</a></li>
    <li><a href="with-binding.html">The <code>with</code> binding</a></li>
</ol>

<h2>Working with form fields</h2>
<ol>
    <li><a href="click-binding.html">The <code>click</code> binding</a></li>
    <li><a href="event-binding.html">The <code>event</code> binding</a></li>
    <li><a href="submit-binding.html">The <code>submit</code> binding</a></li>
    <li><a href="enable-binding.html">The <code>enable</code> binding</a></li>
    <li><a href="disable-binding.html">The <code>disable</code> binding</a></li>
    <li><a href="value-binding.html">The <code>value</code> binding</a></li>
    <li><a href="hasfocus-binding.html">The <code>hasfocus</code> binding</a></li>
    <li><a href="checked-binding.html">The <code>checked</code> binding</a></li>
    <li><a href="options-binding.html">The <code>options</code> binding</a></li>
    <li><a href="selectedOptions-binding.html">The <code>selectedOptions</code> binding</a></li>    
    <li><a href="uniqueName-binding.html">The <code>uniqueName</code> binding</a></li>		
</ol>

<h2>Creating custom bindings</h2>
<ol>
    <li><a href="custom-bindings.html">Creating custom bindings</a></li>
    <li><a href="custom-bindings-controlling-descendant-bindings.html">Controlling descendant bindings</a></li>
    <li><a href="custom-bindings-for-virtual-elements.html">Supporting virtual elements</a></li>
</ol>

<h2>Rendering templates</h2>
<ol>
    <li><a href="template-binding.html">The <code>template</code> binding</a></li>
</ol>

<h2>Further techniques</h2>
<ol>
    <li><a href="json-data.html">Loading and saving JSON data</a></li>
    <li><a href="extenders.html">Extending observables</a></li>
    <li><a href="throttle-extender.html">The <code>throttle</code> extender</a></li>
    <li><a href="unobtrusive-event-handling.html">Unobtrusive event handling</a></li>
    <li><a href="fn.html">Using <code>fn</code> to add custom functions</a></li>
</ol>

<h2>Plugins</h2>
<ol>
    <li><a href="plugins-mapping.html">The <code>mapping</code> plugin</a></li>
</ol>

<h1>More information</h1>
<ol>
    <li><a href="browser-support.html">Browser support</a></li>
    <li><a href="http://groups.google.com/group/knockoutjs">Getting help</a></li>
    <li><a href="links.html">Links to tutorials &amp; examples</a></li>
    <li><a href="amd-loading.html">Usage with AMD using RequireJs (Asynchronous Module Definition)</a></li>
</ol>

		</div>		
	</div>
	<div class="rightCol">
		<div class="documentation sticker">
		    <div class="content">
		    	<h1>Computed Observables</h1>	
		    	<p>What if you&#8217;ve got an <a href='observables.html'>observable</a> for <code>firstName</code>, and another for <code>lastName</code>, and you want to display the full name? That&#8217;s where <em>computed observables</em> come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</p>

<p>For example, given the following view model class,</p>

<pre><code>function AppViewModel() {
    this.firstName = ko.observable(&#39;Bob&#39;);
    this.lastName = ko.observable(&#39;Smith&#39;);
}</code></pre>

<p>&#8230; you could add a computed observable to return the full name:</p>

<pre><code>function AppViewModel() {
    // ... leave firstName and lastName unchanged ...

    this.fullName = ko.computed(function() {
        return this.firstName() + &quot; &quot; + this.lastName();
    }, this);
}    </code></pre>

<p>Now you could bind UI elements to it, e.g.:</p>

<pre><code>The name is &lt;span data-bind=&quot;text: fullName&quot;&gt;&lt;/span&gt;</code></pre>

<p>&#8230; and they will be updated whenever <code>firstName</code> or <code>lastName</code> changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</p>

<h3 id='managing_this'>Managing &#8216;this&#8217;</h3>

<p><em>Beginners may wish to skip this section - as long as you follow the same coding patterns as the examples, you won&#8217;t need to know or care about it!</em></p>

<p>In case you&#8217;re wondering what the second parameter to <code>ko.computed</code> is (the bit where I passed <code>this</code> in the preceding code), that defines the value of <code>this</code> when evaluating the computed observable. Without passing it in, it would not have been possible to refer to <code>this.firstName()</code> or <code>this.lastName()</code>. Experienced JavaScript coders will regard this as obvious, but if you&#8217;re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for <code>this</code>, but JavaScript does, because its functions themselves aren&#8217;t part of any object by default.)</p>

<h4 id='a_popular_convention_that_simplifies_things'>A popular convention that simplifies things</h4>

<p>There&#8217;s a popular convention for avoiding the need to track <code>this</code> altogether: if your viewmodel&#8217;s constructor copies a reference to <code>this</code> into a different variable (traditionally called <code>self</code>), you can then use <code>self</code> throughout your viewmodel and don&#8217;t have to worry about it being redefined to refer to something else. For example:</p>

<pre><code>function AppViewModel() {
    var self = this;

    self.firstName = ko.observable(&#39;Bob&#39;);
    self.lastName = ko.observable(&#39;Smith&#39;);     
    self.fullName = ko.computed(function() {
        return self.firstName() + &quot; &quot; + self.lastName();
    });
}    </code></pre>

<p>Because <code>self</code> is captured in the function&#8217;s closure, it remains available and consistent in any nested functions, such as the <code>ko.computed</code> evaluator. This convention is even more useful when it comes to event handlers, as you&#8217;ll see in many of the <a href='../examples/'>live examples</a>.</p>

<h3 id='dependency_chains_just_work'>Dependency chains just work</h3>

<p>Of course, you can create whole chains of computed observables if you wish. For example, you might have:</p>

<ul>
<li>an <strong>observable</strong> called <code>items</code> representing a set of items</li>

<li>another <strong>observable</strong> called <code>selectedIndexes</code> storing which item indexes have been &#8216;selected&#8217; by the user</li>

<li>a <strong>computed observable</strong> called <code>selectedItems</code> that returns an array of item objects corresponding to the selected indexes</li>

<li>another <strong>computed observable</strong> that returns <code>true</code> or <code>false</code> depending on whether any of <code>selectedItems</code> has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</li>
</ul>

<p>Then, changes to <code>items</code> or <code>selectedIndexes</code> will ripple through the chain of computed observables, which in turn updates any UI bound to them. Very tidy and elegant.</p>

<h1 id='writeable_computed_observables'>Writeable computed observables</h1>

<p><em>Beginners may wish to skip this section - writeable computed observables are fairly advanced and are not necessary in most situations</em></p>

<p>As you&#8217;ve learned, computed observables have a value that is computed from other observables. In that sense, computed observables are normally <em>read-only</em>. What may seem surprising, then, is that it is possible to make computed observables <em>writeable</em>. You just need to supply your own callback function that does something sensible with written values.</p>

<p>You can then use your writeable computed observable exactly like a regular observable - performing two-way data binding with DOM elements, with your own custom logic intercepting all reads and writes. This is a powerful feature with a wide range of possible uses.</p>

<h3 id='example_1_decomposing_user_input'>Example 1: Decomposing user input</h3>

<p>Going back to the classic &#8220;first name + last name = full name&#8221; example, you can turn things back-to-front: make the <code>fullName</code> computed observable writeable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying <code>firstName</code> and <code>lastName</code> observables:</p>

<pre><code>function MyViewModel() {
    this.firstName = ko.observable(&#39;Planet&#39;);
    this.lastName = ko.observable(&#39;Earth&#39;);
    
    this.fullName = ko.computed({
        read: function () {
            return this.firstName() + &quot; &quot; + this.lastName(); 
        },
        write: function (value) {
            var lastSpacePos = value.lastIndexOf(&quot; &quot;);
            if (lastSpacePos &gt; 0) { // Ignore values with no space character
                this.firstName(value.substring(0, lastSpacePos)); // Update &quot;firstName&quot;
                this.lastName(value.substring(lastSpacePos + 1)); // Update &quot;lastName&quot;
            }
        },
        owner: this
    });
}

ko.applyBindings(new MyViewModel());</code></pre>

<p>In this example, the <code>write</code> callback handles incoming values by splitting the incoming text into &#8220;firstName&#8221; and &#8220;lastName&#8221; components, and writing those values back to the underlying observables. You can bind this view model to your DOM in the obvious way, as follows:</p>

<pre><code>&lt;p&gt;First name: &lt;span data-bind=&quot;text: firstName&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Last name: &lt;span data-bind=&quot;text: lastName&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Hello, &lt;input data-bind=&quot;value: fullName&quot;/&gt;!&lt;/h2&gt;</code></pre>

<p>This is the exact opposite of the <a href='../examples/helloWorld.html'>Hello World</a> example, in that here the first and last names are not editable, but the combined full name is editable.</p>

<p>The preceding view model code demonstrates the <em>single parameter syntax</em> for initialising computed observables. You can pass a JavaScript object with any of the following properties:</p>

<ul>
<li><code>read</code> &#8212; Required. A function that is used to evaluate the computed observable&#8217;s current value.</li>

<li><code>write</code> &#8212; Optional. If given, makes the computed observable writeable. This is a function that receives values that other code is trying to write to your computed observable. It&#8217;s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</li>

<li><code>owner</code> &#8212; Optional. If given, defines the value of <code>this</code> whenever KO invokes your <code>read</code> or <code>write</code> callbacks. See the section &#8220;Managing <code>this</code>&#8221; earlier on this page for more information.</li>
</ul>

<h3 id='example_2_a_value_converter'>Example 2: A value converter</h3>

<p>Sometimes you might want to represent a data point on the screen in a different format from its underlying storage. For example, you might want to store a price as a raw float value, but let the user edit it with a currency symbol and fixed number of decimal places. You can use a writeable computed observable to represent the formatted price, mapping incoming values back to the underlying float value:</p>

<pre><code>function MyViewModel() {
    this.price = ko.observable(25.99);
        
    this.formattedPrice = ko.computed({
        read: function () {
            return &#39;$&#39; + this.price().toFixed(2);
        },
        write: function (value) {
            // Strip out unwanted characters, parse as float, then write the raw data back to the underlying &quot;price&quot; observable
            value = parseFloat(value.replace(/[^\.\d]/g, &quot;&quot;));
            this.price(isNaN(value) ? 0 : value); // Write to underlying storage
        },
        owner: this
    });
}

ko.applyBindings(new MyViewModel());</code></pre>

<p>It&#8217;s trivial to bind the formatted price to a text box:</p>

<pre><code>&lt;p&gt;Enter bid price: &lt;input data-bind=&quot;value: formattedPrice&quot;/&gt;&lt;/p&gt;</code></pre>

<p>Now, whenever the user enters a new price, the text box immediately updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&#8217;t enter more than two decimal places, because if they try to, the additional decimal places are immediately removed. Similarly, they can&#8217;t enter negative values, because the <code>write</code> callback strips off any minus sign.</p>

<h3 id='example_3_filtering_and_validating_user_input'>Example 3: Filtering and validating user input</h3>

<p>Example 1 showed how a writeable computed observable can effectively <em>filter</em> its incoming data by choosing not to write certain values back to the underlying observables if they don&#8217;t meet some criteria. It ignored full name values that didn&#8217;t include a space.</p>

<p>Taking this a step further, you could also toggle an <code>isValid</code> flag depending on whether the latest input was satisfactory, and display a message in the UI accordingly. I&#8217;ll explain in a moment an easier way of doing validation, but first consider the following view model, which demonstrates the mechanism:</p>

<pre><code>function MyViewModel() {
    this.acceptedNumericValue = ko.observable(123);
    this.lastInputWasValid = ko.observable(true);
    
    this.attemptedValue = ko.computed({
        read: this.acceptedNumericValue,
        write: function (value) {
            if (isNaN(value))
                this.lastInputWasValid(false);    
            else {
                this.lastInputWasValid(true);
                this.acceptedNumericValue(value); // Write to underlying storage
            }
        },
        owner: this
    });    
}

ko.applyBindings(new MyViewModel());</code></pre>

<p>&#8230; with the following DOM elements:</p>

<pre><code>&lt;p&gt;Enter a numeric value: &lt;input data-bind=&quot;value: attemptedValue&quot;/&gt;&lt;/p&gt;
&lt;div data-bind=&quot;visible: !lastInputWasValid()&quot;&gt;That&#39;s not a number!&lt;/div&gt;</code></pre>

<p>Now, <code>acceptedNumericValue</code> will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating <code>acceptedNumericValue</code>.</p>

<p><strong>Note:</strong> For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its <code>number</code> class on the <code>&lt;input&gt;</code> element. Knockout and jQuery Validation work together nicely, as demonstrated on the <a href='../examples/gridEditor.html'>grid editor</a> example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</p>

<h1 id='how_dependency_tracking_works'>How dependency tracking works</h1>

<p><em>Beginners don&#8217;t need to know about this, but more advanced developers will want to know why I keep making all these claims about KO automatically tracking dependencies and updating the right parts of the UI&#8230;</em></p>

<p>It&#8217;s actually very simple and rather lovely. The tracking algorithm goes like this:</p>

<ol>
<li>Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</li>

<li>While your evaluator function is running, KO keeps a log of any observables (or computed observables) that your evaluator reads the value of.</li>

<li>When your evaluator is finished, KO sets up subscriptions to each of the observables (or computed observables) that you&#8217;ve touched. The subscription callback is set to cause your evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</li>

<li>KO notifies any subscribers about the new value of your computed observable.</li>
</ol>

<p>So, KO doesn&#8217;t just detect your dependencies the first time your evaluator runs - it redetects them every time. This means, for example, that your dependencies can vary dynamically: dependency A could determine whether you also depend on B or C. Then, you&#8217;ll only be re-evaluated when either A or your current choice of B or C changes. You don&#8217;t have to declare dependencies: they&#8217;re inferred at runtime from the code&#8217;s execution.</p>

<p>The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</p>

<h3 id='note_why_circular_dependencies_arent_meaningful'>Note: Why circular dependencies aren&#8217;t meaningful</h3>

<p>Computed observables are supposed to map a set of observable inputs into a single observable output. As such, it doesn&#8217;t make sense to include cycles in your dependency chains. Cycles would <em>not</em> be analogous to recursion; they would be analogous to having two spreadsheet cells that are computed as functions of each other. It would lead to an infinite evaluation loop.</p>

<p>So what does Knockout do if you have got a cycle in your dependency graph? It avoids infinite loops by enforcing the following rule: <strong>a computed observable cannot trigger its own re-evaluation</strong>. This is very unlikely to affect your code. It&#8217;s relevant only if you have a <code>ko.computed</code> (call it <code>A</code>) whose evaluator writes to another observable (call it <code>B</code>) that (directly or via a dependency chain) affects the value of <code>A</code>. In that case, KO will not restart evaluation of <code>A</code> while it is already evaluating, so the resulting value of <code>A</code> will respect only the original value of <code>B</code>, ignoring any update made to <code>B</code> while <code>A</code>&#8217;s evaluator is running.</p>

<h1 id='determining_if_a_property_is_a_computed_observable'>Determining if a property is a computed observable</h1>

<p>In some scenarios, it is useful to programmatically determine if you are dealing with a computed observable. Knockout provides a utility function, <code>ko.isComputed</code> to help with this situation. For example, you might want to exclude computed observables from data that you are sending back to the server.</p>

<pre><code>for (var prop in myObject) {
  if (myObject.hasOwnProperty(prop) &amp;&amp; !ko.isComputed(myObject[prop])) {
      result[prop] = myObject[prop];
  }
}</code></pre>

<p>Additionally, Knockout provides similar functions that can operate on observables and computed observables:</p>

<ul>
<li><code>ko.isObservable</code> - returns true for observables, observableArrays, and all computed observables.</li>

<li><code>ko.isWriteableObservable</code> - returns true for observable, observableArrays, and writeable computed observables.</li>
</ul>

<h1 id='what_happened_to_dependent_observables'>What happened to dependent observables?</h1>

<p>Prior to Knockout 2.0, computed observables were known as <em>dependent observables</em>. With version 2.0, we decided to rename <code>ko.dependentObservable</code> to <code>ko.computed</code> because it is easier to explain, say, and type. But don&#8217;t worry: this won&#8217;t break any existing code. At runtime, <code>ko.dependentObservable</code> refers to the same function instance as <code>ko.computed</code> &#8212; the two are equivalent.</p>    
		    </div>
		    
		    <div class="clear"></div>
		</div>
	</div>	
</div>
            <div class="clear"></div>
            <div class="main-menu">
    <ul>
        <li><a rel="home" href="../index.html">Home</a></li>
        <li><a rel="installation" href="../documentation/installation.html">Download / Install</a></li>
        <li><a rel="tutorials" href="http://learn.knockoutjs.com/">Tutorials</a></li>
        <li><a rel="examples" href="../examples/">Live examples</a></li>
        <li><a rel="documentation" href="../documentation/introduction.html">Documentation</a></li>
        <li><a href="http://groups.google.com/group/knockoutjs">Forum</a></li>
        <li><a href="http://github.com/SteveSanderson/knockout">Source</a></li>
    </ul>
</div>        	
<div class="clear"></div>
        </div>
        
        <div id="page-footer">(c) knockoutjs.com</div> 
        
		  <script type="text/javascript">
		
		  var _gaq = _gaq || [];
		  _gaq.push(['_setAccount', 'UA-32297409-1']);
		  _gaq.push(['_trackPageview']);
		
		  (function() {
		    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		  })();
		
			</script>
    </body>
</html>